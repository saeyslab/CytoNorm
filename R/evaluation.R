#' getDensities
#'
#' Returns a dataframe with 4 columns, containing for every file and every
#' channel of interest the x/y values computed by density.
#'
#' @param files         Full paths of to the fcs files of the samples
#' @param channels      Names of the channels to compute the densities for
#' @param transformList Transformation list to pass to the flowCore
#'                      \code{transform} function
#' @param selection     List with indexation vector for every file.
#' @param ...           Extra parameters to pass to density
#'
#' @examples
#'
#' dir <- system.file("extdata", package = "CytoNorm")
#' files <- list.files(dir, pattern = "fcs$")
#'
#' ff <- flowCore::read.FCS(file.path(dir, files[1]))
#' channels <- grep("Di$", flowCore::colnames(ff), value = TRUE)
#' transformList <- flowCore::transformList(channels,
#'                                          cytofTransform)
#'
#' densities <- getDensities(files = file.path(dir, files),
#'                           channels = channels,
#'                           transformList = transformList,
#'                           quantileValues = c(0.25, 0.5, 0.75))
#'
#' densities$densities$Marker <- paste0(
#'   FlowSOM::get_markers(ff, densities$densities$Channel),
#'   " (", densities$densities$Channel, ")")
#'
#' ggplot(dplyr::filter(densities$densities,
#'                      File == file.path(dir, files[1]))) +
#'   geom_line(aes(x = x, y = y)) +
#'   facet_wrap(~ Marker, scales = "free") +
#'   theme_minimal()
#'
#' ggplot(dplyr::filter(densities$quantiles,
#'                      Channel == FlowSOM::get_channels(ff, "CD66"))) +
#'   geom_vline(aes(xintercept = `0.25`), col = "grey") +
#'   geom_vline(aes(xintercept = `0.5`), col = "grey", lwd = 1) +
#'   geom_vline(aes(xintercept = `0.75`), col = "grey") +
#'   geom_line(aes(x = x, y = y),
#'             data = dplyr::filter(densities$densities,
#'                      Channel == FlowSOM::get_channels(ff, "CD66"))) +
#'   facet_wrap(~ File) +
#'   theme_minimal()
#'
#' @export
getDensities <- function(files,
                         channels,
                         quantileValues = 0.5,
                         transformList = NULL,
                         selection = NULL,
                         ...){

    densities <- data.frame(matrix(ncol = 4, nrow = 0,
                                   dimnames = list(NULL,
                                                   c("File",
                                                     "Channel",
                                                     "x",
                                                     "y"))))
    quantiles <- data.frame(matrix(ncol = 2+length(quantileValues),
                                   nrow = 0,
                                   dimnames = list(NULL,
                                                   c("File",
                                                     "Channel",
                                                     quantileValues))))

    for(file in files){

        o <- capture.output(ff <- flowCore::read.FCS(file))
        if (!is.null(ff) && !is.null(transformList)) {
            ff <- flowCore::transform(ff, transformList)
        }

        if (!is.null(ff) & !is.null(selection)){
            ff <- ff[selection[[file]], ]
        }

        for (channel in channels) {
            dens <- density(ff@exprs[ , channel], ...)
            densities <- rbind(densities,
                               data.frame(File = file,
                                          Channel = channel,
                                          x = dens$x,
                                          y = dens$y))

            quant <- stats::quantile(ff@exprs[, channel],
                                     quantileValues)
            quantiles <- rbind(quantiles,
                               cbind(data.frame(File = file,
                                          Channel = channel),
                                     matrix(quant,
                                            nrow = 1,
                                            dimnames = list(NULL,
                                                            quantileValues))))
        }
    }

    return(named.list(densities,
                      quantiles))
}

#' test_cv
#'
#' Function to inspect whether all control samples contain a similar percentage
#' of cells in all FlowSOM clusters
#'
#' @param fsom           FlowSOM list, as generated by prepareFlowSOM
#' @param cluster_values Vector with all amounts of clusters to test
#'
#' @examples
#'
#' dir <- system.file("extdata", package = "CytoNorm")
#' files <- list.files(dir, pattern = "fcs$")
#' data <- data.frame(File = files,
#'                    Path = file.path(dir, files),
#'                    Type = stringr::str_match(files, "_([12]).fcs")[,2],
#'                    Batch = stringr::str_match(files, "PTLG[0-9]*")[,1],
#'                    stringsAsFactors = FALSE)
#' data$Type <- c("1" = "Train", "2" = "Validation")[data$Type]
#' train_data <- dplyr::filter(data, Type == "Train")
#'
#' ff <- flowCore::read.FCS(data$Path[1])
#' channels <- grep("Di$", flowCore::colnames(ff), value = TRUE)
#' transformList <- flowCore::transformList(channels,
#'                                          cytofTransform)
#'
#' fsom <- prepareFlowSOM(train_data$Path,
#'                        channels,
#'                        nCells = 10000, #1000000
#'                        FlowSOM.params = list(xdim = 15,
#'                                              ydim = 15,
#'                                              nClus = 25,
#'                                              scale = FALSE),
#'                        transformList = transformList,
#'                        seed = 1)
#'
#' cvs <- testCV(fsom,
#'               cluster_values = c(5,15,25,35,45)) # 3:50
#'
#' @export
testCV <- function(fsom,
                   cluster_values = 3:50,
                   plot = TRUE,
                   verbose = FALSE) {

    nClus <- fsom$FlowSOM$map$nNodes
    cluster_labels <- FlowSOM::GetClusters(fsom)

    # Determine metacluster labels
    meta <- list()
    for(mc in cluster_values){
        if(verbose) message("Computing ", mc, " metaclusters")
        meta[[as.character(mc)]] <-
            FlowSOM::metaClustering_consensus(fsom$FlowSOM$map$codes,
                                              mc,
                                              seed = 1)
    }
    meta[[as.character(nClus)]] <- seq_len(nClus)

    # Percentages assigned to each of the clusters per file
    pctgs <- list()
    for(mc in as.character(c(cluster_values, nClus))){
        counts <- matrix(0,
                         nrow = length(unique(fsom$FlowSOM$data[,"File"])),
                         ncol = as.numeric(mc),
                         dimnames = list(unique(fsom$FlowSOM$data[,"File"]),
                                         as.character(seq_len(as.numeric(mc)))))
        tmp <- table(fsom$FlowSOM$data[,"File"],
                     meta[[mc]][cluster_labels])
        counts[rownames(tmp), colnames(tmp)] <- tmp
        pctgs[[mc]] <- t(apply(counts, 1,
                               function(x){ 100 * x/sum(x) }))
    }

    # Coefficient of variation for each of the percentages
    cvs <- list()
    for(mc in as.character(c(cluster_values, nClus))){
        cvs[[mc]] <- apply(pctgs[[mc]],
                           2,
                           function(x){ stats::sd(x) / mean(x)})
    }

    if(plot){
        width <- max(cluster_values)
        chosen <- which(cluster_values == length(levels(fsom$metaclustering)))
        cv_matrix <- do.call(rbind,
                             lapply(cvs[as.character(cluster_values)],
                                    function (x) {
                                        c(x,
                                          rep(NA,
                                              (width - length(x))))
                                    }))
        cv_matrix <- rbind(cv_matrix,
                           matrix(c(cvs[[as.character(nClus)]],
                                    rep(NA, (width - (nClus %% width)))),
                                  ncol = width,
                                  byrow = TRUE))
        rownames(cv_matrix)[length(cluster_values) + 1] <- "Original\nclustering"
        colnames(cv_matrix) <- NULL

        disp <- apply(cv_matrix, 2, function(x) as.character(round(x, 2)))
        disp[cv_matrix < 1.5] <- ""
        disp[is.na(cv_matrix)] <- ""

        pheatmap::pheatmap(cv_matrix,
                           cluster_cols = FALSE,
                           cluster_rows = FALSE,
                           na_col = "white",
                           border_color = "white",
                           gaps_row = c(chosen-1, chosen,
                                        length(cluster_values)),
                           breaks = seq(0, 2.5, length.out = 100),
                           display_numbers = disp)
    }

    return(named.list(pctgs, cvs))
}


#' emdEvaluation
#'
#' Evaluate how much files differ by computing the maximum Earth Movers Distance
#' for all markers and cellTypes.
#'
#' @param files     Full paths of to the fcs files of the control samples.
#' @param transformList Transformation list to pass to the flowCore
#'                  \code{transform} function
#' @param markers   Markers to evaluate (corresponding with the column
#'                  names of the flow frame)
#' @param manual    A list which contains for every file a factor array. These
#'                  arrays contain a cell label for every cell in the files. All
#'                  arrays should have the same levels. Default = NULL, all
#'                  cells are evaluated together.
#' @param binSize   Binsize to approximate distribution. Default = 0.1.
#' @param return_all If TRUE, distributions and pairwise distances are returned
#'                   as well. Default = FALSE.
#'
#' @return A matrix in which the rows represent the cell types, the columns
#' reprents the markers and the values represent the maximal earth movers
#' distances for the distributions between all files
#'
#' @examples
#'    # Describe file names
#'    dir <- system.file("extdata",package="CytoNorm")
#'    fileNames <- c("Gates_PTLG021_Unstim_Control_1.fcs",
#'                    "Gates_PTLG028_Unstim_Control_1.fcs")
#'    labels <- c("PTLG021","PTLG028")
#'    ff <- flowCore::read.FCS(file.path(dir,fileNames[1]))
#'    channelsToNormalize <- flowCore::colnames(ff)[c(10, 11, 14, 16:35, 37, 39:51)]
#'
#'    # Build transform list
#'    transformList <- flowCore::transformList(channelsToNormalize,
#'                                             cytofTransform)
#'    emdEvaluation(file.path(dir,fileNames),
#'                  transformList,
#'                  channelsToNormalize)
#'
#' @export
emdEvaluation <- function(files,
                          transformList,
                          channels,
                          manual = NULL,
                          binSize = 0.1,
                          return_all = FALSE){

    if(is.null(manual)){
        cellTypes <- c("AllCells")
    } else {
        cellTypes <- levels(manual[[1]])
    }

    distr <- list()
    for(file in files){
        print(file)

        distr[[file]] <- list()

        ff <- flowCore::read.FCS(file)
        ff <- flowCore::transform(ff,transformList)
        for(cellType in cellTypes){
            if(is.null(manual)){
                selection <- seq_len(flowCore::nrow(ff))
            } else {
                selection <- manual[[gsub("^Norm_","",gsub(".*/","",file))]]==cellType
            }
            distr[[file]][[cellType]] <-
                apply(flowCore::exprs(ff)[selection,
                                          channels],
                      2,
                      function(x){
                          graphics::hist(x,
                                         breaks = seq(-100,100,by=binSize),
                                         plot = FALSE)$counts
                      })
            any(distr[[file]][[cellType]] != 0)
        }
    }

    distances <- list()
    for(cellType in cellTypes){
        distances[[cellType]] <- list()
        for(marker in channels){
            distances[[cellType]][[marker]] <- matrix(NA,
                                                      nrow=length(files),
                                                      ncol=length(files),
                                                      dimnames=list(files,
                                                                    files))

            for(i in seq_along(files)[-length(files)]){
                file1 <- files[i]
                for(j in seq(i+1,length(files))){
                    file2 <- files[j]
                    distances[[cellType]][[marker]][file1,file2] <-
                        emdist::emd2d(
                            matrix(distr[[file1]][[cellType]][,marker]),
                            matrix(distr[[file2]][[cellType]][,marker]))
                }
            }
        }
    }

    comparison <- matrix(NA,
                         nrow=length(cellTypes),
                         ncol=length(channels),
                         dimnames = list(cellTypes, channels))

    for(cellType in cellTypes){
        for(channel in channels){
            comparison[cellType, channel] <- max(distances[[cellType]][[channel]],
                                               na.rm = TRUE)
        }
    }

    if(return_all){
        return(named.list(distr, distances, comparison))
    } else {
        return(comparison)
    }
}
